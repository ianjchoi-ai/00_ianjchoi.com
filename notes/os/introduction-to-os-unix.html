<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Introduction to OS / Unix</title>
    <link rel="stylesheet" href="../note.css" />
  </head>
  <body>
    <main>
      <h1>Introduction to OS / Unix</h1>

      <h2>What is an Operating System?</h2>
      <p>
        An operating system (OS) is system software that acts as a mediator between hardware and user
        programs. Users do not handle hardware directly; they use the computer through the interfaces
        provided by the OS.
      </p>
      <p>The OS has three core roles.</p>
      <ul>
        <li>
          It abstracts hardware (abstraction).<br />
          -&gt; It wraps complex hardware like CPU, memory, and disk<br />
          -&gt; into simple concepts such as process, virtual memory, and file.<br />
          Developers do not deal with hardware behavior directly; they only use the interfaces provided by
          the OS.
        </li><br />
        <li>
          It manages resources (resource management).<br />
          -&gt; When multiple programs run at the same time,<br />
          -&gt; it decides who uses CPU time, memory space, and disk I/O, when, and how much.<br />
          This directly affects performance, fairness, and efficiency.
        </li><br />
        <li>
          It provides isolation and protection between programs.<br />
          -&gt; One program is prevented from invading another program's memory or resources.<br />
          -&gt; User programs cannot access hardware directly,<br />
          -&gt; and must go through the OS (system calls).<br />
          This structure is the foundation of system stability and security.
        </li>
      </ul>

      <h2>Why Do We Need an OS?</h2>
      <p>Hardware is fast, but difficult to use directly.</p>
      <ul>
        <li>The CPU cannot truly run multiple programs at the same time</li>
        <li>Memory is limited, and conflicts happen easily</li>
        <li>Disks, networks, and devices each have different access methods</li>
      </ul>
      <p>To solve this, the OS:</p>
      <ul>
        <li>Makes it look like many programs run at once</li>
        <li>Distributes resources fairly and efficiently</li>
        <li>Prevents programs from interfering with each other</li>
      </ul>

      <h2>OS as an Abstraction Layer</h2>
      <p>
        The OS provides a safe and consistent abstraction layer on top of complex, risky hardware so you
        do not have to handle it directly.
      </p>
      <p>Hardware is fast, but:</p>
      <ul>
        <li>It has lots of state</li>
        <li>Access rules are strict</li>
        <li>Misuse can break the whole system</li>
      </ul>
      <p>The OS turns this into simpler concepts and interfaces.</p>

      <h3>- CPU ‚Üí Process / Thread</h3>
      <p>The CPU can execute only one instruction at a time.</p>
      <p>But the OS makes it look like multiple programs run at once.</p>
      <p>Process</p>
      <ul>
        <li>An independent execution unit of a running program</li>
        <li>Each process has its own memory space</li>
      </ul>
      <p>Thread</p>
      <ul>
        <li>A unit of execution within a process</li>
        <li>The actual target of CPU scheduling</li>
      </ul>
      <p>The OS:</p>
      <ul>
        <li>Slices CPU time</li>
        <li>Performs context switches</li>
        <li>Runs many processes/threads fairly</li>
      </ul>
      <p>üëâ Developers do not manage CPU scheduling directly. They just "run a program."</p>

      <h3>- Memory ‚Üí Virtual Memory</h3>
      <p>Physical memory is:</p>
      <ul>
        <li>Limited in size</li>
        <li>Prone to conflicts when many programs use it</li>
      </ul>
      <p>The OS abstracts this as virtual memory.</p>
      <ul>
        <li>Each process appears to have its own contiguous memory space</li>
        <li>The OS manages the actual physical layout</li>
        <li>It can use disk as memory when needed (paging)</li>
      </ul>
      <p>üëâ Developers do not need to think about:</p>
      <ul>
        <li>The actual RAM size</li>
        <li>Other programs' memory usage</li>
      </ul>
      <p>They can write code without worrying about them.</p>

      <h3>- Disk ‚Üí File</h3>
      <p>In reality, disks are:</p>
      <ul>
        <li>Divided into sectors and blocks</li>
        <li>Something you would have to manage by location and order</li>
      </ul>
      <p>The OS wraps this into the concept of a file.</p>
      <ul>
        <li>Accessed by name</li>
        <li>Size, permissions, and location are managed by the OS</li>
        <li>Usable whether contiguous or scattered</li>
      </ul>
      <p>üëâ Developers use simple interfaces like <code>read(fd, buf, size);</code>.</p>

      <h3>- Network ‚Üí Socket</h3>
      <p>Networks involve:</p>
      <ul>
        <li>Packet-based transmission</li>
        <li>Latency, loss, and reordering among other complexities</li>
      </ul>
      <p>The OS provides networking through the socket abstraction.</p>
      <ul>
        <li>Open it like a file</li>
        <li>Read from it</li>
        <li>Write to it and close it</li>
      </ul>
      <p>üëâ Even network communication can be handled similarly to file I/O.</p>

      <h2>What is Unix?</h2>
      <p>
        Unix is not just an operating system; it is a design philosophy. It was developed at AT&amp;T Bell
        Labs in the 1960s and 70s, and it became the foundation for most server and cloud systems today.
      </p>
      <p>Unix matters because it created core principles that still hold today.</p>

      <h2>Unix Philosophy</h2>
      <p>Unix follows these principles.</p>
      <ul>
        <li>Make each program do one thing well</li>
        <li>Combine small programs to perform complex tasks</li>
        <li>Use text streams as a standard interface</li>
        <li>Everything is represented as a file</li>
      </ul>
      <p>Because of this:</p>
      <ul>
        <li>Simple but powerful tools emerged</li>
        <li>Systems became flexible and extensible</li>
      </ul>

      <h2>‚ÄúEverything is a File‚Äù</h2>
      <p>One of the most famous Unix ideas is "Everything is a file."</p>
      <ul>
        <li>Regular files</li>
        <li>Directories</li>
        <li>Devices</li>
        <li>Pipes</li>
        <li>Sockets</li>
      </ul>
      <p>All of these are treated like files.</p>
      <p>As a result:</p>
      <ul>
        <li>You can use the same API for many resources</li>
        <li>The system interface stays very simple</li>
      </ul>

      <h2>User Mode vs Kernel Mode</h2>
      <p>Unix-based OSes clearly separate privileges.</p>
      <p>User mode</p>
      <ul>
        <li>Where normal programs run</li>
        <li>No direct hardware access</li>
      </ul>
      <p>Kernel mode</p>
      <ul>
        <li>Where the OS core runs</li>
        <li>Responsible for hardware and resource management</li>
      </ul>
      <p>When a program needs kernel resources, it must request them via system calls.</p>
      <p>This structure is key to system stability and security.</p>

      <h2>Why Unix Still Matters</h2>
      <p>Many systems we use today are influenced by Unix.</p>
      <ul>
        <li>Linux</li>
        <li>macOS</li>
        <li>Android</li>
        <li>Cloud servers</li>
        <li>Container environments</li>
      </ul>
      <p>If you understand Unix:</p>
      <ul>
        <li>Why OS structure looks the way it does</li>
        <li>Why system interfaces have their current form</li>
        <li>Where the root causes of performance issues lie</li>
      </ul>
      <p>you can understand these more deeply.</p>

      <h2>Summary</h2>
      <ul>
        <li>The OS is the core layer between hardware and programs</li>
        <li>Unix is the root of modern OS design</li>
        <li>Unix philosophy and structure are still valid today</li>
      </ul>
      <p>This note is the starting point for:</p>
      <ul>
        <li>Process</li>
        <li>System Call</li>
        <li>File I/O</li>
        <li>Scheduling</li>
        <li>Memory Management</li>
      </ul>
    </main>
  </body>
</html>
